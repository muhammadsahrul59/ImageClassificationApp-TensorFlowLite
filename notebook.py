# -*- coding: utf-8 -*-
"""ProyekDeployment2_3 (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11aXYPcldFO1mtje27pm66SWsGcSnX3Rx
"""

!pip install split-folders
import os
import glob
import warnings
import pathlib
import splitfolders

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from tqdm import tqdm
import itertools

import cv2
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import models, layers
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Input, Flatten, Dense, Dropout, Conv2D, MaxPooling2D
from keras.callbacks import ModelCheckpoint
from sklearn.metrics import confusion_matrix, accuracy_score, classification_report
from sklearn.preprocessing import LabelEncoder
from keras.preprocessing.image import ImageDataGenerator

warnings.filterwarnings('ignore')

!pip install -q kaggle
from google.colab import files
files.upload()

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json
!ls ~/.kaggle

!kaggle datasets download -d shiv28/animal-5-mammal

!unzip animal-5-mammal.zip

splitfolders.ratio('/content/Animal/train', output="mammals-output", seed=42, ratio=(0.8,0.2), group_prefix=None)

train_path = '/content/mammals-output/train'
val_path = '/content/mammals-output/val'
pd.DataFrame(os.listdir(train_path),columns=['Files_Name'])

files = [i for i in glob.glob(train_path + "//*//*")]
np.random.shuffle(files)
labels = [os.path.dirname(i).split("/")[-1] for i in files]
data = zip(files, labels)
dataframe = pd.DataFrame(data, columns = ["Image", "Label"])
dataframe

sns.countplot(x = dataframe["Label"])
plt.xticks(rotation = 50);

files = [i for i in glob.glob(val_path + "//*//*")]
np.random.shuffle(files)
labels = [os.path.dirname(i).split("/")[-1] for i in files]
data = zip(files, labels)
dataframe = pd.DataFrame(data, columns = ["Image", "Label"])
dataframe

sns.countplot(x = dataframe["Label"])
plt.xticks(rotation = 50);

train_data_dir = train_path
val_data_dir =  val_path
batch_size = 32
target_size = (150, 150)

train_datagen = ImageDataGenerator(
    rescale = 1.0/255,
    rotation_range = 30,
    zoom_range=0.2,
    vertical_flip = True,
    shear_range = 0.2,
    fill_mode = 'nearest'
    )

val_datagen = ImageDataGenerator (
    rescale = 1.0/255
    )

train_generator = train_datagen.flow_from_directory(
    train_data_dir,
    batch_size = batch_size,
    class_mode = 'categorical',
    target_size = target_size
    )

val_generator = val_datagen.flow_from_directory(
    val_data_dir,
    batch_size = batch_size,
    class_mode = 'categorical',
    target_size = target_size
)

def get_class_names(generator):
    return list(generator.class_indices.keys())

class_names = get_class_names(train_generator)
print("Class names:", class_names)

def Show_Images(target_gen):
    batch_images, batch_labels = next(target_gen)

    class_labels = list(target_gen.class_indices.keys())

    plt.figure(figsize=(20, 20))
    for n , i in enumerate(list(np.random.randint(0,len(batch_images),16))):
        plt.subplot(4, 4, n + 1)
        plt.imshow(batch_images[i])
        plt.title(class_labels[np.argmax(batch_labels[i])])
        plt.axis('off')
    plt.show()

Show_Images(train_generator)

Show_Images(val_generator)

pre_trained_model = MobileNetV2(weights="imagenet", include_top=False,
                                input_tensor=Input(shape=(150, 150, 3))
                                )

for layer in pre_trained_model.layers:
    layer.trainable = False

model = Sequential()
model.add(pre_trained_model)
model.add(Conv2D(128, (3, 3), activation="relu"))
model.add(MaxPooling2D((2, 2)))
model.add(Flatten(name="flatten"))
model.add(Dropout(0.5))
model.add(Dense(32, activation="relu"))
model.add(Dense(64, activation="relu"))
model.add(Dense(128, activation="relu"))
model.add(Dropout(0.5))
model.add(Dense(5, activation='softmax'))

model.summary()

tf.keras.utils.plot_model(model,
                          to_file='model.png',
                          show_shapes=True,
                          show_layer_names=True,
                          show_dtype=True,dpi=80
                          )

accuracy_threshold = 92e-2
class stop(tf.keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs={}):
    if logs.get('accuracy') > accuracy_threshold and logs.get('val_accuracy') > accuracy_threshold:
      print('\nFor Epoch', epoch, '\nAccuracy has reach = %2.2f%%' %(logs['accuracy']*100), 'training has been stopped.')
      self.model.stop_training=True

callbacks=stop()

checkpoint = ModelCheckpoint("my_model.keras",
                            save_best_only=True
                             )

int_lr = 1e-4
num_epoch = 100

optimizer = tf.optimizers.Adam(learning_rate=int_lr)
model.compile(optimizer=optimizer,
              loss='categorical_crossentropy',
              metrics=['accuracy']
              )

history = model.fit(train_generator,
                    epochs = num_epoch,
                    validation_data = val_generator,
                    callbacks = [callbacks, checkpoint]
                    )

plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.title('Model accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend(['Train', 'Validation'], loc='upper left')
plt.show()

plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Model loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend(['Train', 'Validation'], loc='upper left')
plt.show()

score, acc = model.evaluate(val_generator)
print('Test Loss =', score)
print('Test Accuracy =', acc)

history_ = pd.DataFrame(history.history)
history_

predictions = model.predict(val_generator)

predicted_labels = np.argmax(predictions, axis=1)

true_labels = val_generator.classes

cm = confusion_matrix(true_labels, predicted_labels)

class_names = val_generator.class_indices.keys()

def plot_confusion_matrix(cm, classes, normalize=False, title="Confusion Matrix", cmap=plt.cm.Blues):
    plt.imshow(cm, interpolation="nearest", cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)

    if normalize:
        cm = cm.astype("float") / cm.sum(axis=1)[:, np.newaxis]

    thresh = cm.max() / 2.0
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(j, i, cm[i, j], horizontalalignment="center", color="white" if cm[i, j] > thresh else "black")

    plt.tight_layout()
    plt.ylabel("True label")
    plt.xlabel("Predicted label")

plt.figure(figsize=(8, 6))
plot_confusion_matrix(cm, classes=class_names, title="Confusion Matrix")
plt.show()

def Show_Images_with_Predictions(target_gen, model, class_names):
    batch_images, batch_labels = next(target_gen)

    class_labels = list(target_gen.class_indices.keys())
    class_names = list(class_names)  # Convert dict_keys to a list

    predictions = model.predict(batch_images)
    predicted_labels = np.argmax(predictions, axis=1)

    num_images = len(batch_images)
    num_rows = num_images // 4 + (num_images % 4 > 0)  # Adjusted to handle the extra subplot
    plt.figure(figsize=(20, 5 * num_rows))

    for n, i in enumerate(range(num_images)):
        true_label = class_labels[np.argmax(batch_labels[i])]
        predicted_label = class_names[predicted_labels[i]]

        plt.subplot(num_rows, 4, n + 1)
        plt.imshow(batch_images[i])
        plt.title(f'True: {true_label}\nPredicted: {predicted_label}')
        plt.axis('off')

    plt.show()

# Assuming class_names is defined as:
class_names = train_generator.class_indices.keys()

# Use the function to show images with predictions
Show_Images_with_Predictions(val_generator, model, class_names)

export_dir = 'saved_model/'
tf.saved_model.save(model, export_dir)

converter = tf.lite.TFLiteConverter.from_saved_model(export_dir)
tflite_model = converter.convert()

tflite_model_file = pathlib.Path('mammals.tflite')
tflite_model_file.write_bytes(tflite_model)